<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Œ® EVE-4 ULTRA | CEC-WAM SOVEREIGN CORE</title>

  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  
  <!-- Leaflet CSS for Map Integration -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  
  <link rel="stylesheet" href="js/modules.css" />
  <style>
    :root{
      --bg:#04060a;
      --ink:#a9f7ff;
      --neon:#28f0ff;
      --neon2:#2cff9a;
      --vio:#bc13fe;
      --warn:#ffd166;
      --bad:#ff4d6d;
      --good:#00ff88;
      --gold:#ffd700;

      --panel: rgba(2, 8, 14, 0.82);
      --panel-bg: rgba(2, 8, 14, 0.82);
      --panel2: rgba(4, 12, 22, 0.65);
      --stroke: rgba(40, 240, 255, 0.72);
      --stroke2: rgba(44, 255, 154, 0.55);
      --shadow: 0 0 18px rgba(40,240,255,.25), 0 0 60px rgba(44,255,154,.10);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{ box-sizing:border-box; margin:0; padding:0; font-family: var(--mono); }
    html, body { height:100%; background: var(--bg); color: var(--ink); overflow-x:hidden; }

    /* Enhanced Matrix canvas backdrop with holographic effect */
    #matrix {
      position: fixed;
      inset: 0;
      z-index: 0;
      opacity: 0.35;
      filter: contrast(120%) saturate(140%) hue-rotate(5deg);
      animation: matrixGlow 10s ease-in-out infinite alternate;
    }
    
    @keyframes matrixGlow {
      0% { filter: contrast(120%) saturate(140%) hue-rotate(0deg) brightness(1); }
      50% { filter: contrast(125%) saturate(150%) hue-rotate(5deg) brightness(1.1); }
      100% { filter: contrast(120%) saturate(140%) hue-rotate(0deg) brightness(1); }
    }

    /* Enhanced holographic star dust overlay with HD animation */
    .grain {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(circle at 20% 30%, rgba(40,240,255,.15), transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(188,19,254,.13), transparent 45%),
        radial-gradient(circle at 60% 80%, rgba(44,255,154,.12), transparent 45%),
        radial-gradient(circle at 40% 60%, rgba(255,215,0,.08), transparent 50%),
        linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.65));
      mix-blend-mode: screen;
      animation: grainPulse 8s ease-in-out infinite;
    }
    
    @keyframes grainPulse {
      0%, 100% { 
        opacity: 1;
        filter: blur(1px) brightness(1);
      }
      50% { 
        opacity: 0.75;
        filter: blur(1.5px) brightness(1.1);
      }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,.35); }
    ::-webkit-scrollbar-thumb { background: rgba(40,240,255,.45); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(40,240,255,.65); }

    /* Header */
    header {
      position: relative;
      z-index: 5;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(188,19,254,.45);
      background: rgba(0,0,0,.82);
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }

    .brand {
      display:flex;
      flex-direction:column;
      gap: 2px;
    }
    .brand h1{
      font-size: 14px;
      letter-spacing: 0.18em;
      color: var(--vio);
      text-shadow: 0 0 18px rgba(188,19,254,.65);
      text-transform: uppercase;
      white-space: nowrap;
    }
    .brand small{
      font-size: 11px;
      opacity: .85;
      color: rgba(169,247,255,.9);
      letter-spacing: .12em;
    }

    .statusbar{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid rgba(40,240,255,.45);
      border-radius: 999px;
      background: rgba(2, 10, 18, .65);
      box-shadow: var(--shadow);
      font-size: 11px;
      letter-spacing: .06em;
      white-space: nowrap;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--good);
      box-shadow: 0 0 12px rgba(0,255,136,.8);
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 12px rgba(255,77,109,.85); }
    .dot.warn{ background: var(--warn); box-shadow: 0 0 12px rgba(255,209,102,.8); }

    /* Main container */
    #mainContainer {
      position: relative;
      z-index: 4;
      padding: 12px;
      overflow-y: auto;
      height: calc(100vh - 280px);
    }

    /* Grid layout */
    #dashGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 12px;
      margin-bottom: 12px;
    }

    /* Card styles with enhanced HD glassmorphism */
    .card{
      border-radius: 16px;
      border: 1px solid rgba(40,240,255,.65);
      background: var(--panel);
      backdrop-filter: blur(20px) saturate(200%) brightness(1.1);
      -webkit-backdrop-filter: blur(20px) saturate(200%) brightness(1.1);
      box-shadow: var(--shadow), 0 8px 32px rgba(40,240,255,.15), inset 0 1px 1px rgba(255,255,255,.1);
      overflow:hidden;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(40,240,255,.1), transparent);
      animation: shimmer 3s infinite;
    }
    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    .card:hover{
      border-color: rgba(44,255,154,.85);
      box-shadow: 0 0 35px rgba(40,240,255,.45), 0 0 90px rgba(44,255,154,.25), inset 0 1px 1px rgba(255,255,255,.2);
      transform: translateY(-2px);
    }
    .card .head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(40,240,255,.18);
      background: rgba(0,0,0,.35);
    }
    .card .head .title{
      font-size: 11px;
      letter-spacing: .16em;
      color: rgba(44,255,154,.92);
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .card .body{ padding: 12px; }

    .bigVal{
      font-size: 28px;
      color: rgba(255,255,255,.95);
      text-shadow: 0 0 22px rgba(40,240,255,.25);
      letter-spacing: .04em;
      font-weight: 600;
    }
    .subVal{
      margin-top: 8px;
      font-size: 12px;
      opacity: .9;
      letter-spacing: .08em;
      color: rgba(169,247,255,.8);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .tag{
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(44,255,154,.25);
      background: rgba(44,255,154,.08);
      font-size: 10px;
    }

    /* Star map container */
    #starMapContainer {
      position: relative;
      height: 480px;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(40,240,255,.55);
      background: radial-gradient(circle at 50% 45%, rgba(8,20,40,.9), rgba(0,0,0,.98) 70%);
      box-shadow: var(--shadow);
      margin-bottom: 12px;
    }

    #threeCanvas {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
    }

    /* HUD overlay */
    .hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .scanlines::before{
      content:"";
      position:absolute;
      inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.025),
        rgba(255,255,255,.025) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px
      );
      opacity:.18;
      mix-blend-mode: overlay;
    }

    .vignette::after{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(circle at 50% 50%, transparent 40%, rgba(0,0,0,.65) 80%, rgba(0,0,0,.85) 100%);
      opacity: .85;
    }

    /* Center radar ring */
    .ring {
      position:absolute;
      left: 50%;
      top: 50%;
      width: 640px;
      height: 640px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 2px solid rgba(40,240,255,.18);
      box-shadow: 0 0 0 1px rgba(44,255,154,.10), inset 0 0 40px rgba(40,240,255,.08);
    }
    .ring::before, .ring::after{
      content:"";
      position:absolute;
      inset: 15%;
      border-radius: 50%;
      border: 1px dashed rgba(44,255,154,.16);
    }
    .ring::after{
      inset: 30%;
      border-style: solid;
      border-color: rgba(40,240,255,.12);
    }

    .sweep {
      position:absolute;
      left: 50%;
      top: 50%;
      width: 640px;
      height: 640px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: conic-gradient(from 0deg, rgba(44,255,154,.35), rgba(44,255,154,0) 35%);
      mask: radial-gradient(circle, rgba(0,0,0,0) 0 32%, rgba(0,0,0,1) 33% 100%);
      opacity: .20;
      animation: sweep 3.2s linear infinite;
      filter: blur(.3px);
    }
    @keyframes sweep { to { transform: translate(-50%, -50%) rotate(360deg); } }

    /* Corner HUD panels with enhanced HD glassmorphism */
    .hudPanel{
      position:absolute;
      min-width: 240px;
      border-radius: 12px;
      border: 1px solid rgba(40,240,255,.45);
      background: rgba(0, 10, 18, .75);
      box-shadow: var(--shadow), 0 8px 32px rgba(0,0,0,.5), inset 0 1px 1px rgba(255,255,255,.08);
      padding: 10px;
      backdrop-filter: blur(24px) saturate(220%) brightness(1.05);
      -webkit-backdrop-filter: blur(24px) saturate(220%) brightness(1.05);
      pointer-events: auto;
      transition: all 0.3s ease;
    }
    .hudPanel:hover {
      border-color: rgba(40,240,255,.65);
      background: rgba(0, 10, 18, .85);
      box-shadow: var(--shadow), 0 12px 48px rgba(40,240,255,.2), inset 0 1px 1px rgba(255,255,255,.12);
    }
    .hudPanel h3{
      font-size: 10px;
      letter-spacing: .16em;
      color: rgba(44,255,154,.95);
      text-transform: uppercase;
      margin-bottom: 6px;
      opacity: .95;
    }
    .kv{ display:grid; grid-template-columns: 1fr auto; gap: 4px 8px; font-size: 10px; opacity: .95; }
    .kv .k{ color: rgba(169,247,255,.75); }
    .kv .v{ color: rgba(255,255,255,.9); text-shadow: 0 0 12px rgba(40,240,255,.12); }

    .hud-tl{ left: 12px; top: 12px; }
    .hud-tr{ right: 12px; top: 12px; }
    .hud-br{ right: 12px; bottom: 12px; }
    .hud-bl{ left: 12px; bottom: 12px; }

    /* Table styles */
    .dataTable{
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .dataTable thead{
      background: rgba(0,0,0,.35);
      border-bottom: 1px solid rgba(40,240,255,.25);
    }
    .dataTable th{
      padding: 8px 10px;
      text-align: left;
      font-size: 10px;
      letter-spacing: .12em;
      color: rgba(44,255,154,.85);
      text-transform: uppercase;
    }
    .dataTable td{
      padding: 8px 10px;
      border-bottom: 1px solid rgba(40,240,255,.08);
      color: rgba(220,255,255,.85);
    }
    .dataTable tbody tr:hover{
      background: rgba(40,240,255,.05);
    }

    .badge{
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 9px;
      letter-spacing: .08em;
      text-transform: uppercase;
      font-weight: 600;
    }
    .badge.stable{ background: rgba(0,255,136,.15); color: var(--good); border: 1px solid rgba(0,255,136,.35); }
    .badge.active{ background: rgba(40,240,255,.15); color: var(--neon); border: 1px solid rgba(40,240,255,.35); }
    .badge.locked{ background: rgba(188,19,254,.15); color: var(--vio); border: 1px solid rgba(188,19,254,.35); }
    .badge.verified{ background: rgba(255,215,0,.15); color: var(--gold); border: 1px solid rgba(255,215,0,.35); }

    /* Timeline */
    .timeline{
      position: relative;
      padding-left: 24px;
    }
    .timeline::before{
      content: "";
      position: absolute;
      left: 6px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: linear-gradient(180deg, rgba(40,240,255,.45), rgba(44,255,154,.25));
    }
    .timelineItem{
      position: relative;
      margin-bottom: 16px;
      padding-left: 18px;
    }
    .timelineItem::before{
      content: "";
      position: absolute;
      left: -19px;
      top: 4px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(44,255,154,.75);
      box-shadow: 0 0 12px rgba(44,255,154,.55);
      border: 2px solid rgba(0,0,0,.65);
    }
    .timelineItem .date{
      font-size: 10px;
      color: rgba(40,240,255,.75);
      letter-spacing: .10em;
      margin-bottom: 3px;
    }
    .timelineItem .desc{
      font-size: 11px;
      color: rgba(220,255,255,.85);
      line-height: 1.5;
    }

    /* Gauge chart */
    .gauge{
      position: relative;
      width: 100%;
      height: 140px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .gaugeCircle{
      position: relative;
      width: 120px;
      height: 120px;
    }
    .gaugeCircle svg{
      transform: rotate(-90deg);
    }
    .gaugeValue{
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .gaugeValue .num{
      font-size: 28px;
      font-weight: 600;
      color: rgba(255,255,255,.95);
      text-shadow: 0 0 20px rgba(44,255,154,.45);
    }
    .gaugeValue .label{
      font-size: 9px;
      letter-spacing: .12em;
      color: rgba(169,247,255,.75);
      text-transform: uppercase;
    }

    /* Action buttons */
    .actionBtn{
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid rgba(40,240,255,.55);
      background: rgba(40,240,255,.12);
      color: rgba(255,255,255,.95);
      letter-spacing: .12em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 18px rgba(40,240,255,.14);
      transition: all 0.2s;
      font-size: 10px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .actionBtn:hover{ 
      filter: brightness(1.18); 
      transform: translateY(-1px);
      box-shadow: 0 0 25px rgba(40,240,255,.25);
    }
    .actionBtn:active{ transform: translateY(0); }

    /* EVE Terminal */
    #terminal {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 12px;
      z-index: 6;
      border-radius: 16px;
      border: 1px solid rgba(40,240,255,.55);
      background: rgba(0,0,0,.85);
      box-shadow: var(--shadow);
      overflow: hidden;
      max-height: 240px;
    }

    #terminal .termHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      background: rgba(0,0,0,.45);
      border-bottom: 1px solid rgba(40,240,255,.18);
    }
    .termHead .left{
      display:flex;
      align-items:center;
      gap: 10px;
      letter-spacing: .16em;
      text-transform: uppercase;
      font-size: 11px;
      color: rgba(188,19,254,.95);
      text-shadow: 0 0 14px rgba(188,19,254,.40);
    }
    .termHead .right{
      font-size: 10px;
      opacity: .85;
      letter-spacing: .10em;
      color: rgba(169,247,255,.75);
    }

    #termLog{
      height: 130px;
      overflow:auto;
      padding: 10px 12px;
      font-size: 11px;
      line-height: 1.5;
      color: rgba(220,255,255,.85);
    }
    .line{ margin-bottom: 5px; }
    .you{ color: rgba(255,255,255,.95); }
    .eve{ color: rgba(44,255,154,.95); }
    .sys{ color: rgba(169,247,255,.75); }

    #termInputRow{
      display:flex;
      gap: 10px;
      padding: 10px 12px;
      border-top: 1px solid rgba(40,240,255,.18);
      background: rgba(0,0,0,.35);
    }
    #termInput{
      flex:1;
      padding: 9px 12px;
      border-radius: 10px;
      border: 1px solid rgba(40,240,255,.45);
      background: rgba(4,10,18,.75);
      color: rgba(255,255,255,.95);
      outline: none;
      font-size: 11px;
    }
    #termBtn{
      padding: 9px 16px;
      border-radius: 10px;
      border: 1px solid rgba(44,255,154,.55);
      background: rgba(44,255,154,.12);
      color: rgba(255,255,255,.95);
      letter-spacing: .12em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(44,255,154,.14);
      transition: all 0.2s;
      font-size: 10px;
      font-weight: 600;
    }
    #termBtn:hover{ filter: brightness(1.15); transform: scale(1.02); }
    #termBtn:active{ transform: scale(0.98); }

    /* Responsive */
    @media (max-width: 1280px){
      #dashGrid{ grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
      .hudPanel{ min-width: 200px; font-size: 9px; }
      .ring,.sweep{ width: 480px; height: 480px; }
    }
    @media (max-width: 768px){
      header{ flex-direction:column; align-items:flex-start; }
      .statusbar{ justify-content:flex-start; }
      #termLog{ height: 100px; }
      .hudPanel{ display: none; }
      #starMapContainer{ height: 360px; }
    }
  </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEC-WAM-HOT-CORE Live Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0E0E1A 0%, #1A1A2E 100%);
            color: #EAEAEA;
            overflow-x: hidden;
        }
        
        /* Lock Screen Styles with premium HD glassmorphism */
        #lockScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.98) 0%, rgba(26, 26, 46, 0.98) 100%);
            backdrop-filter: blur(32px) saturate(200%) brightness(1.1);
            -webkit-backdrop-filter: blur(32px) saturate(200%) brightness(1.1);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 0 100px rgba(40,240,255,.05);
        }
        
        #lockScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .lock-content {
            text-align: center;
            color: #00D9FF;
            background: rgba(10, 20, 40, 0.5);
            backdrop-filter: blur(10px) saturate(150%);
            -webkit-backdrop-filter: blur(10px) saturate(150%);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 20px;
            padding: 50px 40px;
            box-shadow: 0 0 40px rgba(0, 217, 255, 0.2);
        }
        
        .lock-title {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px #00D9FF;
        }
        
        .lock-subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 40px;
        }
        
        .scanner {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 0 auto 30px;
        }
        
        .scanner-ring {
            position: absolute;
            border-radius: 50%;
            border: 3px solid #00D9FF;
            animation: pulse 2s infinite;
        }
        
        .scanner-ring:nth-child(1) {
            width: 200px;
            height: 200px;
            top: 0;
            left: 0;
        }
        
        .scanner-ring:nth-child(2) {
            width: 160px;
            height: 160px;
            top: 20px;
            left: 20px;
            border-width: 2px;
            animation-delay: 0.5s;
        }
        
        .scanner-ring:nth-child(3) {
            width: 120px;
            height: 120px;
            top: 40px;
            left: 40px;
            border-width: 1px;
            animation-delay: 1s;
        }
        
        .scanner-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }
        
        .scan-status {
            font-size: 1.3rem;
            margin-bottom: 30px;
            color: #00FF88;
        }
        
        .scanning {
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 50%, 100% {
                opacity: 1;
            }
            25%, 75% {
                opacity: 0.5;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 193, 7, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(255, 193, 7, 0.7);
            }
        }
        
        .unlock-button {
            background: linear-gradient(90deg, #00D9FF 0%, #00FF88 100%);
            border: none;
            color: #0E0E1A;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            transition: all 0.3s;
        }
        
        .unlock-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.7);
        }
        
        .unlock-button.override {
            background: rgba(255, 193, 7, 0.25);
            border: 2px solid #FFC107;
            color: #FFC107;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }
        
        .unlock-button.override:hover {
            background: rgba(255, 193, 7, 0.4);
            box-shadow: 0 0 40px rgba(255, 193, 7, 0.7);
            transform: scale(1.08);
        }
        
        .unlock-button.override-pulse {
            animation: pulse 2s infinite;
        }
        
        .lock-hint {
            margin-top: 30px;
            font-size: 0.9rem;
            opacity: 0.6;
        }
        
        /* Main Content Styles */
        #mainContent {
            display: none;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        #mainContent.visible {
            display: block;
        }
        
        header {
            text-align: center;
            padding: 40px 20px;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.2);
        }
        
        h1 {
            color: #00D9FF;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .status-bar {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: rgba(26, 26, 46, 0.8);
            border: 1px solid #00D9FF;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.2);
        }
        
        .card h2 {
            color: #00D9FF;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: bold;
        }
        
        .metric-value {
            color: #00FF88;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .data-table th {
            background: rgba(0, 217, 255, 0.2);
            padding: 12px;
            text-align: left;
            color: #00D9FF;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }
        
        .data-table td {
            padding: 10px 12px;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        
        .data-table tr:nth-child(even) {
            background: rgba(0, 217, 255, 0.05);
        }
        
        .status-perfect {
            background-color: rgba(0, 255, 136, 0.2) !important;
            border-left: 4px solid #00FF88;
        }
        
        .status-todo {
            background-color: rgba(255, 193, 7, 0.2) !important;
            border-left: 4px solid #FFC107;
        }
        
        .status-active {
            background-color: rgba(33, 150, 243, 0.2) !important;
            border-left: 4px solid #2196F3;
        }
        
        .status-stable {
            background-color: rgba(158, 158, 158, 0.2) !important;
            border-left: 4px solid #9E9E9E;
        }
        
        #starmap-container {
            width: 100%;
            height: 600px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .refresh-button {
            background: linear-gradient(90deg, #00D9FF 0%, #00FF88 100%);
            border: none;
            color: #0E0E1A;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .refresh-button:hover {
            transform: scale(1.05);
        }
        
        .streamlit-embed {
            width: 100%;
            height: 800px;
            border: 2px solid #00D9FF;
            border-radius: 10px;
            margin-top: 30px;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 15px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(0, 217, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00FF88;
        }
        
        .filter-controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .filter-button {
            background: rgba(0, 217, 255, 0.2);
            border: 1px solid #00D9FF;
            color: #00D9FF;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .filter-button:hover {
            background: rgba(0, 217, 255, 0.4);
        }
        
        .filter-button.active {
            background: #00D9FF;
            color: #0E0E1A;
        }
        
        .export-button {
            background: linear-gradient(90deg, #00FF88 0%, #00D9FF 100%);
            border: none;
            color: #0E0E1A;
            padding: 10px 25px;
            font-size: 0.9rem;
            font-weight: bold;
            border-radius: 20px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
            transition: all 0.3s;
        }
        
        .export-button:hover {
            transform: scale(1.05);
        }
        
        footer {
            text-align: center;
            padding: 30px 20px;
            margin-top: 40px;
            opacity: 0.7;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #00D9FF;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            #starmap-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <!-- Lock Screen -->
    <div id="lockScreen">
        <div class="lock-content">
            <h1 class="lock-title">üîê BIOMETRIC AUTHENTICATION</h1>
            <p class="lock-subtitle">CEC-WAM-HOT-CORE SECURITY PROTOCOL</p>
            
            <div class="scanner">
                <div class="scanner-ring"></div>
                <div class="scanner-ring"></div>
                <div class="scanner-ring"></div>
                <div class="scanner-icon">üîç</div>
            </div>
            
            <div id="scanStatus" class="scan-status">
                <span class="scanning">‚óè Initializing biometric authentication...</span>
            </div>
            
            <div id="biometricButtons" style="display: none; margin-top: 20px;">
                <button class="unlock-button" onclick="authenticateBiometric()">üîì AUTHENTICATE</button>
            </div>
            
            <div id="setupButtons" style="display: none; margin-top: 20px;">
                <button class="unlock-button" onclick="registerBiometric()">üì± REGISTER BIOMETRIC</button>
            </div>
            
            <!-- Manual Override Button (always available as fallback) -->
            <div id="manualOverrideButton" style="display: none; margin-top: 20px;">
                <button class="unlock-button override" onclick="manualOverride()">
                    ‚ö†Ô∏è MANUAL OVERRIDE
                </button>
            </div>
            
            <p id="lockHint" class="lock-hint">Checking biometric availability...</p>
        </div>
    </div>
    
    <!-- Main Content -->
    <div id="mainContent">
        <header>
            <h1>üåå CEC-WAM-HOT-CORE Live Dashboard</h1>
            <div class="status-bar">
                <strong>System Status:</strong> <span style="color: #00FF88;">OPERATIONAL</span> | 
                <strong>Last Sync:</strong> <span id="lastSync">--:--:--</span>
            </div>
        </header>
        
        <button class="refresh-button" onclick="refreshData()">üîÑ Refresh Data</button>
        
        <div class="dashboard-grid">
            <!-- PSI Price Card -->
            <div class="card">
                <h2>üíé PSI-COIN PRICE</h2>
                <div id="psiPrice" class="loading">Loading...</div>
                <div class="chart-container">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>
            
            <!-- Data Summary Card -->
            <div class="card">
                <h2>üìä Data Summary</h2>
                <div id="dataSummary" class="loading">Loading...</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Avg Value</div>
                        <div class="stat-value" id="avgValue">--</div>
                    </div>
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Total Value</div>
                        <div class="stat-value" id="totalValue">--</div>
                    </div>
                </div>
            </div>
            
            <!-- Status Distribution Card -->
            <div class="card">
                <h2>üìà Status Distribution</h2>
                <div id="statusDist" class="loading">Loading...</div>
                <div class="chart-container">
                    <canvas id="statusChart"></canvas>
                </div>
            </div>
            
            <!-- Real-Time Performance Card -->
            <div class="card">
                <h2>‚ö° Real-Time Performance</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Load Time</div>
                        <div class="stat-value" id="loadTime">--</div>
                    </div>
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Data Points</div>
                        <div class="stat-value" id="dataPoints">--</div>
                    </div>
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Refresh Rate</div>
                        <div class="stat-value">30 sec</div>
                    </div>
                    <div class="stat-item">
                        <div style="font-size: 0.9rem; opacity: 0.8;">Status</div>
                        <div class="stat-value" style="color: #00FF88;">LIVE</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Data Table -->
        <div class="card">
            <h2>üìã Live Data Feed</h2>
            <div class="filter-controls">
                <button class="filter-button active" onclick="filterData('ALL', event)">All Data</button>
                <button class="filter-button" onclick="filterData('PERFECT', event)">Perfect</button>
                <button class="filter-button" onclick="filterData('TODO', event)">To-Do</button>
                <button class="filter-button" onclick="filterData('ACTIVE', event)">Active</button>
                <button class="filter-button" onclick="filterData('STABLE', event)">Stable</button>
                <button class="export-button" onclick="exportData()">üì• Export CSV</button>
            </div>
            <div id="dataTable" class="loading">Loading data from Google Sheets...</div>
        </div>
        
        <!-- Trends Card -->
        <div class="card">
            <h2>üìä Data Trends & Analytics</h2>
            <div class="chart-container" style="height: 400px;">
                <canvas id="trendsChart"></canvas>
            </div>
        </div>
        
        <!-- 3D Star Map -->
        <div class="card">
            <h2>üåü 3D Star Map</h2>
            <p style="margin-bottom: 15px;">Explore three celestial bodies:</p>
            <ul style="margin-left: 20px; margin-bottom: 20px; line-height: 1.8;">
                <li>üåü <strong>Alpha Centauri</strong> - Yellow star (center)</li>
                <li>üåç <strong>TRAPPIST-1e</strong> - Blue-green exoplanet</li>
                <li>üî¥ <strong>Ross 128 b</strong> - Red exoplanet</li>
            </ul>
            <div id="starmap-container">
                <canvas id="starmap"></canvas>
            </div>
        </div>
        
        <!-- Streamlit Embed (Optional - uncomment and add your URL) -->
        <!--
        <div class="card">
            <h2>üöÄ Full Streamlit Dashboard</h2>
            <iframe class="streamlit-embed" src="https://YOUR-APP.streamlit.app"></iframe>
        </div>
      </div>

      <!-- Map Integration with Camera Selection -->
      <div class="card" style="grid-column: span 2;">
        <div class="head">
          <div class="title">üó∫Ô∏è LIVE CAMERA MAP</div>
          <div class="pill" style="padding:5px 10px;">
            <span class="dot" id="mapStatus"></span><span id="mapStatusText">INITIALIZING</span>
          </div>
        </div>
        <div class="body">
          <div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="actionBtn" onclick="toggleMapView()" style="flex: 1; min-width: 120px;">üó∫Ô∏è TOGGLE MAP</button>
            <button class="actionBtn" onclick="refreshCameras()" style="flex: 1; min-width: 120px;">üìπ REFRESH CAMS</button>
            <button class="actionBtn" onclick="toggleWeatherLayer()" style="flex: 1; min-width: 120px;">üå§Ô∏è WEATHER</button>
            <button class="actionBtn" onclick="toggleTrafficLayer()" style="flex: 1; min-width: 120px;">üöó TRAFFIC</button>
          </div>
          <div id="mapContainer" style="height: 500px; border-radius: 12px; overflow: hidden; display: block; background: rgba(0,0,0,0.3);"></div>
          <div id="cameraInfoPanel" style="margin-top: 12px; padding: 12px; border-radius: 8px; background: rgba(0,0,0,0.3); display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <h4 style="color: var(--neon2); font-size: 12px; margin: 0;">SELECTED CAMERA</h4>
              <button class="actionBtn" onclick="closeCameraPanel()" style="padding: 4px 12px; font-size: 10px;">‚úï CLOSE</button>
            </div>
            <div id="cameraDetails"></div>
          </div>
        </div>
      </div>

      <!-- Weather Dashboard -->
      <div class="card">
        <div class="head">
          <div class="title">üå§Ô∏è WEATHER STATUS</div>
          <div class="pill" style="padding:5px 10px;">
            <span class="dot" id="weatherStatus"></span><span id="weatherStatusText">LOADING</span>
          </div>
        </div>
        <div class="body">
          <div id="weatherDisplay">
            <div style="text-align: center; padding: 20px;">
              <div class="bigVal" id="weatherTemp">--¬∞F</div>
              <div class="subVal" style="flex-direction: column; gap: 4px; margin-top: 12px;">
                <span class="tag" id="weatherCondition">Condition: --</span>
                <span class="tag" id="weatherLocation">Location: --</span>
                <span class="tag" id="weatherHumidity">Humidity: --%</span>
                <span class="tag" id="weatherWind">Wind: -- mph</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Traffic Dashboard -->
      <div class="card">
        <div class="head">
          <div class="title">üöó TRAFFIC STATUS</div>
          <div class="pill" style="padding:5px 10px;">
            <span class="dot" id="trafficStatus"></span><span id="trafficStatusText">LOADING</span>
          </div>
        </div>
        <div class="body">
          <div id="trafficDisplay">
            <div style="padding: 12px;">
              <div class="subVal" style="flex-direction: column; gap: 8px;">
                <div style="display: flex; justify-content: space-between;">
                  <span>Active Incidents:</span>
                  <span style="color: var(--warn)" id="incidentCount">--</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span>Average Speed:</span>
                  <span style="color: var(--good)" id="avgSpeed">-- mph</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span>Traffic Flow:</span>
                  <span style="color: var(--neon2)" id="trafficFlow">--</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span>Last Updated:</span>
                  <span id="trafficUpdate">--</span>
                </div>
              </div>
              <button class="actionBtn" onclick="refreshTraffic()" style="width: 100%; margin-top: 12px;">üîÑ REFRESH TRAFFIC</button>
            </div>
          </div>
        </div>
      </div>

    </div>

    <!-- New Real-time Modules Section -->
    <div style="margin-top: 20px;">
      <!-- Live Federal Way Feed Card -->
      <div class="card" style="grid-column: span 2; margin-bottom: 12px;">
        <div class="head">
          <div class="title">üìπ FEDERAL WAY LIVE FEED</div>
          <span style="font-size:10px;opacity:.75">HD CAMERA STREAM</span>
        </div>
        <div class="body" style="padding: 0;">
          <div id="federalWayFeed"></div>
        </div>
      </div>

      <!-- Crime Alert System Card -->
      <div class="card" style="grid-column: span 2; margin-bottom: 12px;">
        <div class="head">
          <div class="title">üö® CRIME ALERT FEED</div>
          <span style="font-size:10px;opacity:.75">FEDERAL WAY POLICE SCANNER</span>
        </div>
        <div class="body" style="padding: 0;">
          <div id="crimeAlertSystem"></div>
        </div>
      </div>
    </div>
  </div>

  <section id="terminal">
    <div class="termHead">
      <div class="left"><span class="dot"></span> EVE // COMMAND BUS</div>
      <div class="right" id="termRight">type: <span style="color:rgba(44,255,154,.9)">help</span></div>
    </div>
    <div id="termLog"></div>
    <div id="termInputRow">
      <input id="termInput" autocomplete="off" placeholder="EVE> enter command (help, status, prices, data, vault, timeline, clear, refresh)" />
      <button id="termBtn">SEND</button>
    </div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  
  <!-- Leaflet JS for Map Integration -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <script>
    // ========== CONFIGURATION ==========
    // To configure your OpenWeatherMap API key, add this line before loading this page:
    // window.OPENWEATHER_API_KEY = 'your-api-key-here';
    // Or the weather feature will use demo/fallback data.
    
    // Embedded data from repository
    const DATA = {
      net_liquidity: 1250039,
      psi_mass: 176452.66,
      total_mass: 100001.33,
      dark_energy_index: 0.999,
      black_hole_flow_rate: 1.33,
      r_ratio_efficiency: 10.96,
      btc_allowance: 1.33,
      agi_timeline: "Q4 2026",
      resource_used_pct: 98.75,
      resource_left_pct: 1.25,
      psi_minted: 200,
      valuation_usd: 34100000,
      escrow_pct: 84,
      network_load_pct: 43,
      latency_ms: 12,
      needed_usd: 56363,
      psi_gauge_pct: 0
    };

    const CFG = {
      psiBalance: DATA.psi_mass,
      psiMapsTo: "sol",
      pollMs: 15_000,
    };

    const $ = (id) => document.getElementById(id);
    let startTime = Date.now();

    // ---------- Clock & Uptime ----------
    function tickClock(){
      const now = new Date();
      const clockEl = $("clock");
      const heartbeatEl = $("hudHeartbeat");
      const uptimeEl = $("hudUptime");
      
      // Only update if elements exist (after dashboard unlock)
      if (clockEl) {
        clockEl.textContent = "SYSTEM TIME: " + now.toLocaleString();
      }
      if (heartbeatEl) {
        heartbeatEl.textContent = now.toLocaleTimeString();
      }
      if (uptimeEl) {
        const uptimeSec = Math.floor((Date.now() - startTime) / 1000);
        const h = Math.floor(uptimeSec / 3600);
        const m = Math.floor((uptimeSec % 3600) / 60);
        const s = uptimeSec % 60;
        uptimeEl.textContent = `${h}h ${m}m ${s}s`;
      }
    }
    setInterval(tickClock, 1000);
    tickClock();

    // ---------- Initialize from embedded data ----------
    function initEmbeddedData(){
      $("netLiquidity").textContent = "$" + DATA.net_liquidity.toLocaleString();
      $("valuation").textContent = "$" + (DATA.valuation_usd / 1000000).toFixed(1) + "M";
      $("btcAllowance").textContent = DATA.btc_allowance + " BTC";
      $("neededUsd").textContent = "$" + DATA.needed_usd.toLocaleString();
      $("rRatio").textContent = DATA.r_ratio_efficiency;
      $("gaugeNum").textContent = DATA.resource_used_pct + "%";
      $("resourceLeft").textContent = DATA.resource_left_pct + "%";
      $("hudEscrow").textContent = DATA.escrow_pct + "%";
      $("networkLoad").textContent = DATA.network_load_pct + "%";
      $("latencyMs").textContent = DATA.latency_ms + "ms";
      
      // Update gauge
      const circumference = 2 * Math.PI * 52;
      const offset = circumference - (DATA.resource_used_pct / 100) * circumference;
      $("gaugeBar").style.strokeDashoffset = offset;
    }
    initEmbeddedData();

    // ---------- Safe fetch ----------
    async function fetchJson(url, { timeoutMs = 8000 } = {}){
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url, { signal: ctrl.signal, cache: "no-store" });
        if(!res.ok) throw new Error("HTTP " + res.status);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    // ---------- Live crypto feeds ----------
    async function pollFeeds(){
      const netDot = $("netDot");
      const netStatus = $("netStatus");
      const sourceStatus = $("sourceStatus");

      try{
        netDot.className = "dot warn";
        netStatus.textContent = "LINK: CONNECTING‚Ä¶";

        const cgUrl = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana&vs_currencies=usd&include_24hr_change=true";
        const cg = await fetchJson(cgUrl);

        const btc = cg.bitcoin?.usd ?? null;
        const eth = cg.ethereum?.usd ?? null;
        const sol = cg.solana?.usd ?? null;

        $("hudBtc").textContent = btc ? "$" + btc.toLocaleString() : "‚Äî";
        $("hudEth").textContent = eth ? "$" + eth.toLocaleString() : "‚Äî";
        $("hudSol").textContent = sol ? "$" + sol.toLocaleString() : "‚Äî";

        const map = CFG.psiMapsTo;
        const mapPrice = map === "btc" ? btc : map === "eth" ? eth : sol;
        const mapChange = map === "btc" ? cg.bitcoin?.usd_24h_change : map === "eth" ? cg.ethereum?.usd_24h_change : cg.solana?.usd_24h_change;

        $("psiBalance").textContent = CFG.psiBalance.toLocaleString(undefined, { maximumFractionDigits: 2 }) + " Œ®";
        $("psiUsd").textContent = (mapPrice ? ("$" + (CFG.psiBalance * mapPrice).toLocaleString(undefined,{maximumFractionDigits:2})) : "‚Äî USD");
        $("psiChange").textContent = (typeof mapChange === "number")
          ? ((mapChange >= 0 ? "+" : "") + mapChange.toFixed(2) + "% 24h")
          : "‚Äî 24h";

        const entropy = (Math.abs(Math.sin(Date.now()/14000))*0.42 + 0.58);
        $("hudEntropy").textContent = entropy.toFixed(3);
        $("hudLatency").textContent = Math.floor(12 + Math.random()*18) + " ms";
        $("hudSync").textContent = "OK/" + (100 - Math.floor(Math.random()*3)) + "%";

        $("hudFeed").textContent = "CoinGecko";
        $("sourceStatus").textContent = "FEEDS: LIVE";
        netStatus.textContent = "LINK: STABLE";
        netDot.className = "dot";
      } catch (e){
        $("sourceStatus").textContent = "FEEDS: DEGRADED";
        $("netStatus").textContent = "LINK: DEGRADED";
        $("netDot").className = "dot bad";
        console.error("Feed error:", e);
      }
    }

    function refreshAllData(){
      eveSay("üîÑ Refreshing all data feeds...");
      pollFeeds();
    }

    function refreshPSI(){
      eveSay("üíé Refreshing PSI wallet data...");
      pollFeeds();
    }

    pollFeeds();
    setInterval(pollFeeds, CFG.pollMs);

    // ---------- Wallet connect ----------
    function connectWallet(){
      eveSay("üîó Wallet connection initiated...");
      setTimeout(() => {
        eveSay("‚úÖ Wallet connected: PHANTOM (simulated)");
        $("walletMode").textContent = "CONNECTED";
      }, 1200);
    }

    // ---------- Bonding curve ----------
    const bondCtx = $("bondChart").getContext("2d");
    const bondState = {
      t: 0,
      labels: Array.from({length: 30}, (_,i)=> String(i - 29)),
      data: [],
    };

    function bondingPriceAt(step){
      const supply = 10_000 + step * 250;
      const a = 0.0009;
      const b = 0.06;
      return a * Math.sqrt(supply) + b * Math.sin(step/3.2);
    }

    for(let i=0;i<30;i++) bondState.data.push(bondingPriceAt(i));

    const bondChart = new Chart(bondCtx, {
      type: "line",
      data: {
        labels: bondState.labels,
        datasets: [{
          label: "Bond Curve",
          data: bondState.data,
          tension: 0.3,
          borderWidth: 2,
          pointRadius: 0,
          borderColor: "rgba(44,255,154,.85)",
          backgroundColor: "rgba(44,255,154,.12)",
          fill: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: true }
        },
        scales: {
          x: { display: false },
          y: {
            ticks: { color: "rgba(169,247,255,.75)", font: { size: 10 } },
            grid: { color: "rgba(40,240,255,.08)" }
          }
        }
      }
    });

    function tickBond(){
      bondState.t++;
      bondState.data.shift();
      bondState.data.push(bondingPriceAt(bondState.t + 29));
      bondChart.update("none");
      $("bondMeta").textContent = "T+" + bondState.t.toString().padStart(4,"0") + " / SUPPLY SIM";
    }
    setInterval(tickBond, 1400);
    tickBond();

    // ---------- Three.js Enhanced Starfield ----------
    const threeCanvas = $("threeCanvas");
    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true, alpha: true });
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0028);

    const camera = new THREE.PerspectiveCamera(65, 1, 0.1, 1500);
    camera.position.set(0, 0, 180);

    // Stars
    const starGeo = new THREE.BufferGeometry();
    const starCount = 12000;
    const pos = new Float32Array(starCount * 3);
    const col = new Float32Array(starCount * 3);

    for(let i=0;i<starCount;i++){
      const i3 = i*3;
      pos[i3+0] = (Math.random()-0.5) * 1200;
      pos[i3+1] = (Math.random()-0.5) * 800;
      pos[i3+2] = (Math.random()-0.5) * 1200;

      const tint = 0.6 + Math.random()*0.4;
      col[i3+0] = tint;
      col[i3+1] = tint * (0.9 + Math.random()*0.2);
      col[i3+2] = 1.0;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    starGeo.setAttribute("color", new THREE.BufferAttribute(col, 3));

    const stars = new THREE.Points(
      starGeo,
      new THREE.PointsMaterial({
        size: 1.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.92,
        depthWrite: false
      })
    );
    scene.add(stars);

    // Neon streaks
    const streakGeo = new THREE.BufferGeometry();
    const streakCount = 1600;
    const spos = new Float32Array(streakCount * 3);
    for(let i=0;i<streakCount;i++){
      const i3=i*3;
      spos[i3+0]=(Math.random()-0.5)*800;
      spos[i3+1]=(Math.random()-0.5)*500;
      spos[i3+2]=(Math.random()-0.5)*1000;
    }
    streakGeo.setAttribute("position", new THREE.BufferAttribute(spos,3));
    const streaks = new THREE.Points(
      streakGeo,
      new THREE.PointsMaterial({
        size: 2.8,
        color: 0x28f0ff,
        transparent: true,
        opacity: 0.12,
        depthWrite: false
      })
    );
    scene.add(streaks);

    // Nebula particles
    const nebulaGeo = new THREE.BufferGeometry();
    const nebulaCount = 800;
    const npos = new Float32Array(nebulaCount * 3);
    for(let i=0;i<nebulaCount;i++){
      const i3=i*3;
      npos[i3+0]=(Math.random()-0.5)*600;
      npos[i3+1]=(Math.random()-0.5)*400;
      npos[i3+2]=(Math.random()-0.5)*600;
    }
    nebulaGeo.setAttribute("position", new THREE.BufferAttribute(npos,3));
    const nebula = new THREE.Points(
      nebulaGeo,
      new THREE.PointsMaterial({
        size: 4.5,
        color: 0xbc13fe,
        transparent: true,
        opacity: 0.08,
        depthWrite: false
      })
    );
    scene.add(nebula);

    function resizeThreeToElement(){
      const el = $("starMapContainer");
      const rect = el.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width));
      const h = Math.max(2, Math.floor(rect.height));
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }

    new ResizeObserver(resizeThreeToElement).observe($("starMapContainer"));
    window.addEventListener("resize", resizeThreeToElement);
    resizeThreeToElement();

    let lastTs = performance.now();
    function animate(ts){
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      stars.rotation.y += dt * 0.08;
      stars.rotation.x += dt * 0.025;
      
      streaks.rotation.y -= dt * 0.05;
      nebula.rotation.x += dt * 0.03;

      camera.position.x = Math.sin(ts/7000) * 8;
      camera.position.y = Math.cos(ts/8500) * 5;

      renderer.render(scene, camera);

      $("hudCoords").textContent = (
        (camera.position.x/10).toFixed(2) + "," +
        (camera.position.y/10).toFixed(2) + "," +
        (camera.position.z/10).toFixed(1)
      );

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ---------- Matrix rain ----------
    const m = $("matrix");
    const mctx = m.getContext("2d");
    const glyphs = "Œ®01ŒîŒ£Œ©ŒªŒºŒΩŒæœÄœÉœÑœÖœÜœáœàŒ∂„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé";
    let mW=0, mH=0, cols=0, drops=[];

    function resizeMatrix(){
      mW = m.width = window.innerWidth;
      mH = m.height = window.innerHeight;
      cols = Math.floor(mW / 14);
      drops = Array.from({length: cols}, () => Math.random()*mH/14);
    }
    window.addEventListener("resize", resizeMatrix);
    resizeMatrix();

    function drawMatrix(){
      mctx.fillStyle = "rgba(0,0,0,0.08)";
      mctx.fillRect(0,0,mW,mH);

      mctx.font = "13px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
      for(let i=0;i<cols;i++){
        const x = i * 14;
        const y = drops[i] * 14;
        const ch = glyphs[Math.floor(Math.random()*glyphs.length)];
        mctx.fillStyle = "rgba(40,240,255,0.70)";
        mctx.fillText(ch, x, y);

        if(y > mH && Math.random() > 0.985) drops[i] = 0;
        drops[i] += 0.75 + Math.random()*0.40;
      }
      requestAnimationFrame(drawMatrix);
    }
    requestAnimationFrame(drawMatrix);

    // ---------- EVE Terminal ----------
    function termLine(kind, text){
      const div = document.createElement("div");
      div.className = "line " + kind;
      div.textContent = text;
      $("termLog").appendChild(div);
      $("termLog").scrollTop = $("termLog").scrollHeight;
    }

    function eveSay(text){ termLine("eve", "EVE: " + text); }
    function sysSay(text){ termLine("sys", "SYS: " + text); }

    async function cmdStatus(){
      sysSay("üéØ CEC-WAM CORE: NOMINAL");
      sysSay("üì° FEEDS: " + $("sourceStatus").textContent.replace("FEEDS: ",""));
      sysSay("üíé PSI BALANCE: " + CFG.psiBalance.toFixed(2) + " Œ®");
      sysSay("üí∞ NET LIQUIDITY: $" + DATA.net_liquidity.toLocaleString());
      sysSay("‚ö° RESOURCE USAGE: " + DATA.resource_used_pct + "%");
      eveSay("‚úÖ All systems operational.");
    }

    async function cmdPrices(){
      eveSay("üí∞ Fetching live prices‚Ä¶");
      await pollFeeds();
      eveSay("BTC " + $("hudBtc").textContent + " | ETH " + $("hudEth").textContent + " | SOL " + $("hudSol").textContent);
    }

    function cmdHelp(){
      eveSay("Commands: help, status, prices, data, vault, timeline, refresh, ping, clear, biometric");
    }

    function cmdData(){
      sysSay("üìä EMBEDDED DATA SNAPSHOT:");
      sysSay("  Net Liquidity: $" + DATA.net_liquidity.toLocaleString());
      sysSay("  PSI Mass: " + DATA.psi_mass.toFixed(2) + " Œ®");
      sysSay("  Dark Energy Index: " + DATA.dark_energy_index);
      sysSay("  BTC Allowance: " + DATA.btc_allowance + " BTC");
      sysSay("  Valuation: $" + (DATA.valuation_usd / 1000000).toFixed(1) + "M");
      sysSay("  AGI Timeline: " + DATA.agi_timeline);
      eveSay("Data loaded from live.json.");
    }

    function cmdVault(){
      sysSay("üîê CEC VAULT ACCESS:");
      sysSay("  GEMINI AGI: Master API Key Active");
      sysSay("  PHANTOM BRIDGE: TXT Record Verified");
      sysSay("  PSI-COIN: 100,001.33 Units");
      sysSay("  VALUATION: $1,250,039");
      sysSay("  BITCOIN: 1.33 BTC (~$121,478 USD)");
      eveSay("Vault data secured.");
    }

    function cmdTimeline(){
      sysSay("üìÖ PROJECT TIMELINE:");
      sysSay("  2025-11-27: Resource conflict resolved");
      sysSay("  2025-12-02: Ghost Protocol executed");
      sysSay("  2026-01-08: +176,452.66 PSI recorded");
      sysSay("  2026-01-16: CEC Matrix updated ($34.1M)");
      sysSay("  TODAY: GOD_MODE active (99.9% focus)");
      eveSay("Full timeline visible in dashboard.");
    }

    function cmdPing(){
      const ms = Math.floor(12 + Math.random()*25);
      eveSay("üèì PING OK: " + ms + "ms");
    }

    function cmdBiometric(){
      const credId = localStorage.getItem('biometric_credential_id');
      const regDate = localStorage.getItem('biometric_registered_at');
      const lastAuth = localStorage.getItem('last_auth_time');
      
      sysSay("üîê BIOMETRIC AUTHENTICATION STATUS:");
      if (credId) {
        sysSay("  Status: ‚úì REGISTERED");
        sysSay("  Credential ID: " + credId.substring(0, 20) + "...");
        if (regDate) {
          sysSay("  Registered: " + new Date(regDate).toLocaleString());
        }
        if (lastAuth) {
          sysSay("  Last Auth: " + new Date(lastAuth).toLocaleString());
        }
        sysSay("  Type: use 'biometric reset' to clear");
      } else {
        sysSay("  Status: ‚úó NOT REGISTERED");
        sysSay("  Type: Reload page to register biometrics");
      }
      eveSay("Biometric status retrieved.");
    }

    function cmdBiometricReset(){
      localStorage.removeItem('biometric_credential_id');
      localStorage.removeItem('biometric_registered_at');
      localStorage.removeItem('last_auth_time');
      sysSay("üîê BIOMETRIC CREDENTIALS CLEARED");
      eveSay("Reload the page to register new biometric credentials.");
    }

    function handleCmd(raw){
      const s = raw.trim();
      if(!s) return;

      termLine("you", "YOU: " + s);

      const parts = s.split(/\s+/);
      const cmd = parts[0].toLowerCase();

      if(cmd === "help") return cmdHelp();
      if(cmd === "clear"){ $("termLog").innerHTML = ""; return eveSay("Log cleared."); }
      if(cmd === "status") return cmdStatus();
      if(cmd === "prices") return cmdPrices();
      if(cmd === "data") return cmdData();
      if(cmd === "vault") return cmdVault();
      if(cmd === "timeline") return cmdTimeline();
      if(cmd === "refresh") return refreshAllData();
      if(cmd === "ping") return cmdPing();
      if(cmd === "biometric") {
        if(parts[1] && parts[1].toLowerCase() === "reset") return cmdBiometricReset();
        return cmdBiometric();
      }

      eveSay("Unknown command. Type: help");
    }

    $("termBtn").addEventListener("click", () => {
      const v = $("termInput").value;
      $("termInput").value = "";
      handleCmd(v);
    });
    $("termInput").addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        const v = $("termInput").value;
        $("termInput").value = "";
        handleCmd(v);
      }
    });

    // ========== MAP, CAMERA, WEATHER, TRAFFIC INTEGRATION ==========
    
    // State management
    const MAP_STATE = {
      map: null,
      cameras: [],
      weatherLayer: false,
      trafficLayer: false,
      markers: [],
      selectedCamera: null,
      currentWeather: null,
      trafficData: null,
      intervals: {
        cameras: null,
        traffic: null,
        weather: null
      }
    };

    // API Configuration - Note: API keys should be configured via environment variables
    const API_CONFIG = {
      WSDOT_CAMERAS: 'https://www.wsdot.wa.gov/Traffic/api/HighwayCameras/HighwayCamerasREST.svc/GetCamerasAsJson',
      OPENWEATHER_KEY: window.OPENWEATHER_API_KEY || 'demo', // Set via environment variable or use demo mode
      WSDOT_TRAFFIC: 'https://www.wsdot.wa.gov/Traffic/api/TravelTimes/TravelTimesREST.svc/GetTravelTimesAsJson'
    };

    // Initialize Map
    function initializeMap() {
      if (!MAP_STATE.map) {
        try {
          MAP_STATE.map = L.map('mapContainer').setView([47.6062, -122.3321], 10); // Seattle center
          
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 18
          }).addTo(MAP_STATE.map);
          
          updateMapStatus('ONLINE', true);
          eveSay("üó∫Ô∏è Map initialized successfully.");
          
          // Load cameras on map initialization
          loadWSDOTCameras();
        } catch (error) {
          console.error('Map initialization error:', error);
          updateMapStatus('ERROR', false);
          eveSay("‚ö†Ô∏è Map initialization failed: " + error.message);
        }
      }
    }

    // Load WSDOT Traffic Cameras
    async function loadWSDOTCameras() {
      try {
        updateMapStatus('LOADING', false);
        
        const response = await fetchJson(API_CONFIG.WSDOT_CAMERAS, { timeoutMs: 10000 });
        
        if (!response) {
          throw new Error('No camera data received');
        }
        
        MAP_STATE.cameras = response;
        
        // Clear existing markers
        MAP_STATE.markers.forEach(marker => marker.remove());
        MAP_STATE.markers = [];
        
        // Add camera markers to map
        let validCameras = 0;
        response.forEach(camera => {
          if (camera.Latitude && camera.Longitude) {
            const marker = L.marker([camera.Latitude, camera.Longitude], {
              icon: L.divIcon({
                className: 'custom-camera-marker',
                html: '<div style="background: var(--neon); width: 12px; height: 12px; border-radius: 50%; border: 2px solid var(--neon2); box-shadow: 0 0 10px var(--neon);"></div>',
                iconSize: [16, 16]
              })
            }).addTo(MAP_STATE.map);
            
            marker.on('click', () => selectCamera(camera));
            MAP_STATE.markers.push(marker);
            validCameras++;
          }
        });
        
        updateMapStatus(`${validCameras} CAMS`, true);
        eveSay(`üìπ Loaded ${validCameras} traffic cameras.`);
        
        // Load weather for Seattle
        loadWeatherData(47.6062, -122.3321, 'Seattle, WA');
        
      } catch (error) {
        console.error('Camera loading error:', error);
        updateMapStatus('CAM ERROR', false);
        eveSay("‚ö†Ô∏è Failed to load cameras: " + error.message);
      }
    }

    // Select and display camera
    function selectCamera(camera) {
      MAP_STATE.selectedCamera = camera;
      
      const panel = $("cameraInfoPanel");
      const details = $("cameraDetails");
      
      panel.style.display = 'block';
      
      let cameraHTML = `
        <div style="display: flex; flex-direction: column; gap: 8px;">
          <div style="font-size: 14px; font-weight: 700; color: var(--neon);">${camera.Title || 'Camera'}</div>
          <div style="font-size: 11px; opacity: 0.85;">
            <strong>Location:</strong> ${camera.Description || 'N/A'}<br>
            <strong>Direction:</strong> ${camera.Direction || 'N/A'}<br>
            <strong>Coordinates:</strong> ${camera.Latitude ? camera.Latitude.toFixed(4) : 'N/A'}, ${camera.Longitude ? camera.Longitude.toFixed(4) : 'N/A'}
          </div>
      `;
      
      if (camera.ImageURL) {
        cameraHTML += `
          <div style="margin-top: 8px;">
            <img src="${camera.ImageURL}" alt="${camera.Title}" 
              style="width: 100%; border-radius: 8px; border: 1px solid var(--stroke);" 
              onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div style="display: none; padding: 20px; text-align: center; background: rgba(255,77,109,0.1); border-radius: 8px; color: var(--bad);">
              Camera feed unavailable
            </div>
          </div>
        `;
      }
      
      cameraHTML += `
          <div style="margin-top: 8px; font-size: 10px; opacity: 0.7;">
            Last updated: ${new Date().toLocaleString()}
          </div>
        </div>
      `;
      
      details.innerHTML = cameraHTML;
      
      // Load weather for camera location
      if (camera.Latitude && camera.Longitude) {
        loadWeatherData(camera.Latitude, camera.Longitude, camera.Title);
      }
      
      eveSay(`üìπ Selected camera: ${camera.Title}`);
    }

    // Load Weather Data
    async function loadWeatherData(lat, lon, locationName) {
      try {
        updateWeatherStatus('LOADING');
        
        // Note: Using a demo endpoint - replace with actual API key
        const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=imperial&appid=${API_CONFIG.OPENWEATHER_KEY}`;
        
        try {
          const weather = await fetchJson(weatherUrl, { timeoutMs: 8000 });
          
          MAP_STATE.currentWeather = weather;
          
          $("weatherTemp").textContent = Math.round(weather.main.temp) + "¬∞F";
          $("weatherCondition").textContent = "Condition: " + (weather.weather && weather.weather.length > 0 ? weather.weather[0].description : 'N/A');
          $("weatherLocation").textContent = "Location: " + (locationName || weather.name);
          $("weatherHumidity").textContent = "Humidity: " + weather.main.humidity + "%";
          $("weatherWind").textContent = "Wind: " + Math.round(weather.wind.speed) + " mph";
          
          updateWeatherStatus('ONLINE');
          eveSay(`üå§Ô∏è Weather updated for ${locationName || weather.name}`);
        } catch (weatherError) {
          // Fallback to mock data if API key is demo/invalid
          $("weatherTemp").textContent = "52¬∞F";
          $("weatherCondition").textContent = "Condition: Partly Cloudy";
          $("weatherLocation").textContent = "Location: " + locationName;
          $("weatherHumidity").textContent = "Humidity: 65%";
          $("weatherWind").textContent = "Wind: 8 mph";
          updateWeatherStatus('DEMO');
        }
        
      } catch (error) {
        console.error('Weather loading error:', error);
        updateWeatherStatus('ERROR');
        eveSay("‚ö†Ô∏è Weather data unavailable");
      }
    }

    // Load Traffic Data
    async function loadTrafficData() {
      try {
        updateTrafficStatus('LOADING');
        
        const response = await fetchJson(API_CONFIG.WSDOT_TRAFFIC, { timeoutMs: 10000 });
        
        MAP_STATE.trafficData = response;
        
        // Calculate traffic statistics
        let totalIncidents = 0;
        let totalSpeed = 0;
        let speedCount = 0;
        
        if (Array.isArray(response)) {
          response.forEach(route => {
            if (route.AverageSpeed) {
              totalSpeed += route.AverageSpeed;
              speedCount++;
            }
            if (route.Description && route.Description.toLowerCase().includes('incident')) {
              totalIncidents++;
            }
          });
        }
        
        const avgSpeed = speedCount > 0 ? Math.round(totalSpeed / speedCount) : 0;
        const flowStatus = avgSpeed > 50 ? 'GOOD' : avgSpeed > 30 ? 'MODERATE' : 'SLOW';
        
        $("incidentCount").textContent = totalIncidents;
        $("avgSpeed").textContent = avgSpeed + " mph";
        $("trafficFlow").textContent = flowStatus;
        $("trafficUpdate").textContent = new Date().toLocaleTimeString();
        
        updateTrafficStatus('ONLINE');
        eveSay(`üöó Traffic data updated: ${totalIncidents} incidents, avg ${avgSpeed} mph`);
        
      } catch (error) {
        console.error('Traffic loading error:', error);
        
        // Fallback to mock data
        $("incidentCount").textContent = "2";
        $("avgSpeed").textContent = "45 mph";
        $("trafficFlow").textContent = "MODERATE";
        $("trafficUpdate").textContent = new Date().toLocaleTimeString();
        
        updateTrafficStatus('DEMO');
        eveSay("‚ö†Ô∏è Traffic data using fallback");
      }
    }

    // UI Control Functions
    function toggleMapView() {
      const container = $("mapContainer");
      if (container.style.display === 'none') {
        container.style.display = 'block';
        if (!MAP_STATE.map) {
          initializeMap();
        } else {
          MAP_STATE.map.invalidateSize();
        }
        eveSay("üó∫Ô∏è Map view enabled");
      } else {
        container.style.display = 'none';
        eveSay("üó∫Ô∏è Map view hidden");
      }
    }

    function refreshCameras() {
      eveSay("üîÑ Refreshing camera feeds...");
      loadWSDOTCameras();
    }

    function toggleWeatherLayer() {
      MAP_STATE.weatherLayer = !MAP_STATE.weatherLayer;
      if (MAP_STATE.weatherLayer) {
        eveSay("üå§Ô∏è Weather layer enabled");
        // In production, add weather overlay tiles here
      } else {
        eveSay("üå§Ô∏è Weather layer disabled");
      }
    }

    function toggleTrafficLayer() {
      MAP_STATE.trafficLayer = !MAP_STATE.trafficLayer;
      if (MAP_STATE.trafficLayer) {
        eveSay("üöó Traffic layer enabled");
        loadTrafficData();
        // In production, add traffic overlay tiles here
      } else {
        eveSay("üöó Traffic layer disabled");
      }
    }

    function refreshTraffic() {
      eveSay("üîÑ Refreshing traffic data...");
      loadTrafficData();
    }

    function closeCameraPanel() {
      $("cameraInfoPanel").style.display = 'none';
      MAP_STATE.selectedCamera = null;
    }

    // Status update helpers
    function updateMapStatus(text, isOnline) {
      $("mapStatusText").textContent = text;
      const dot = $("mapStatus");
      dot.className = isOnline ? "dot" : "dot warn";
    }

    function updateWeatherStatus(status) {
      const statusMap = {
        'LOADING': { text: 'LOADING', class: 'warn' },
        'ONLINE': { text: 'ONLINE', class: '' },
        'DEMO': { text: 'DEMO', class: 'warn' },
        'ERROR': { text: 'ERROR', class: 'bad' }
      };
      const s = statusMap[status] || statusMap['ERROR'];
      $("weatherStatusText").textContent = s.text;
      $("weatherStatus").className = "dot " + s.class;
    }

    function updateTrafficStatus(status) {
      const statusMap = {
        'LOADING': { text: 'LOADING', class: 'warn' },
        'ONLINE': { text: 'ONLINE', class: '' },
        'DEMO': { text: 'DEMO', class: 'warn' },
        'ERROR': { text: 'ERROR', class: 'bad' }
      };
      const s = statusMap[status] || statusMap['ERROR'];
      $("trafficStatusText").textContent = s.text;
      $("trafficStatus").className = "dot " + s.class;
    }

    // Auto-initialize map and load data
    setTimeout(() => {
      initializeMap();
      loadTrafficData();
    }, 2000);

    // Auto-refresh intervals
    MAP_STATE.intervals.cameras = setInterval(() => {
      if (MAP_STATE.map) {
        loadWSDOTCameras();
      }
    }, 60000); // Refresh cameras every 60 seconds

    MAP_STATE.intervals.traffic = setInterval(() => {
      loadTrafficData();
    }, 45000); // Refresh traffic every 45 seconds

    MAP_STATE.intervals.weather = setInterval(() => {
      if (MAP_STATE.selectedCamera && MAP_STATE.selectedCamera.Latitude) {
        loadWeatherData(
          MAP_STATE.selectedCamera.Latitude, 
          MAP_STATE.selectedCamera.Longitude, 
          MAP_STATE.selectedCamera.Title
        );
      }
    }, 300000); // Refresh weather every 5 minutes

    // Cleanup intervals on page unload
    window.addEventListener('beforeunload', () => {
      if (MAP_STATE.intervals.cameras) clearInterval(MAP_STATE.intervals.cameras);
      if (MAP_STATE.intervals.traffic) clearInterval(MAP_STATE.intervals.traffic);
      if (MAP_STATE.intervals.weather) clearInterval(MAP_STATE.intervals.weather);
    });

    // ========== END MAP, CAMERA, WEATHER, TRAFFIC INTEGRATION ==========
    // Initialize new real-time modules
    let starMapViz = null;
    let federalWayFeed = null;
    let crimeAlertSystem = null;

    // Wait for DOM to be fully loaded before initializing modules
    setTimeout(() => {
      // Initialize Star Map (already exists in the page)
      if (typeof StarMapVisualization !== 'undefined') {
        starMapViz = new StarMapVisualization('threeCanvas');
        console.log('Star Map initialized');
      }

      // Initialize Federal Way Feed
      if (typeof FederalWayLiveFeed !== 'undefined') {
        federalWayFeed = new FederalWayLiveFeed('federalWayFeed');
        console.log('Federal Way Feed initialized');
      }

      // Initialize Crime Alert System
      if (typeof CrimeAlertSystem !== 'undefined') {
        crimeAlertSystem = new CrimeAlertSystem('crimeAlertSystem');
        console.log('Crime Alert System initialized');
      }
    }, 500);

    // Boot sequence
    sysSay("üöÄ Booting EVE-4 ULTRA HUD‚Ä¶");
    sysSay("üîó Loading embedded data: live.json, BlackHoles.csv, pump.fun.csv‚Ä¶");
    sysSay("üåå Initializing 3D starfield with 14,400 particles‚Ä¶");
    sysSay("üì° Establishing live feeds: CoinGecko API‚Ä¶");
    sysSay("üó∫Ô∏è Loading map integration with traffic cameras‚Ä¶");
    sysSay("üå§Ô∏è Connecting to weather services‚Ä¶");
    sysSay("üöó Initializing traffic monitoring system‚Ä¶");
    setTimeout(() => {
      eveSay("‚úÖ ALL SYSTEMS ONLINE. Type 'help' for commands.");
      eveSay("üíé PSI Balance: " + CFG.psiBalance.toLocaleString() + " Œ®");
      eveSay("üéØ Mode: GOD_MODE | Focus: 99.9%");
      eveSay("üó∫Ô∏è Map & Camera system: INITIALIZING");
    }, 1200);
  </script>

  <!-- Real-time functionality modules -->
  <script src="js/starmap.js"></script>
  <script src="js/federal-way-feed.js"></script>
  <script src="js/crime-alerts.js"></script>
  <script src="js/google-drive-export.js"></script>

</body><button id="eve-mic" style="background:#0f0;color:#000;padding:10px;border:none;cursor:pointer;">Talk to Eve</button>
<script>
const micBtn = document.getElementById('eve-mic');
micBtn.onclick = () => {
  const rec = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  rec.lang = 'en-US';
  rec.onresult = e => {
    const said = e.results[0][0].transcript;
    document.body.innerHTML += `<p><strong>You:</strong> ${said}</p>`;
    // Eve replies here‚Äîpipe to console or mock
  };
  rec.start();
};
</script>
        -->
        
        <footer>
            <p>üåå CEC-WAM-HOT-CORE Live Dashboard</p>
            <p>Powered by Google Sheets | CoinGecko API | Three.js</p>
            <p style="margin-top: 10px; font-size: 0.9rem;">
                <a href="https://docs.google.com/spreadsheets/d/e/2PACX-1vREgUUHPCzTBWK8i1PWBrE2E4pKRTAgaReJahFqmrTetCZyCO0QHVlAleodUsTlJv_86KpzH_NPv9dv/pub?output=csv" 
                   style="color: #00D9FF; text-decoration: none;" target="_blank">View Data Source</a>
            </p>
        </footer>
    </div>
    
    <script>
        // =================================================================
        // CEC-WAM-HOT-CORE Live Dashboard - JavaScript
        // 
        // Performance Optimizations:
        // - Cached star field generation (10k vertices)
        // - Parallel API calls with Promise.all()
        // - Debounced resize handler (250ms)
        // - Visibility-based auto-refresh
        // - Improved error messages
        // =================================================================
        
        // ============================================================
        // WebAuthn Biometric Authentication System
        // ============================================================
        
        // Configuration constants
        const AUTO_AUTH_DELAY_MS = 2000; // Delay before auto-authentication
        
        // Global variable to track manual override timeout
        let manualOverrideTimeout = null;
        
        // Helper function to safely escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to safely set status messages
        function setStatusMessage(element, message, color) {
            if (element) {
                element.innerHTML = `<span style="color: ${color};">${escapeHtml(message)}</span>`;
            }
        }
        
        // Helper function to generate random challenge
        function generateRandomChallenge() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return array;
        }
        
        // Helper function to convert ArrayBuffer to Base64
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            const binary = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
            return btoa(binary);
        }
        
        // Helper function to convert Base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = Uint8Array.from(binary, char => char.charCodeAt(0));
            return bytes.buffer;
        }
        
        // Check if biometric credentials are registered
        function hasRegisteredBiometric() {
            return localStorage.getItem('biometric_credential_id') !== null;
        }
        
        // Register new biometric credential
        async function registerBiometric() {
            const scanStatus = document.getElementById('scanStatus');
            const setupButtons = document.getElementById('setupButtons');
            
            try {
                scanStatus.innerHTML = '<span class="scanning">‚óè Registering biometric credential...</span>';
                setupButtons.style.display = 'none';
                
                // Check WebAuthn support
                if (!window.PublicKeyCredential) {
                    throw new Error('WebAuthn is not supported on this device/browser');
                }
                
                const challenge = generateRandomChallenge();
                const userId = new Uint8Array(16);
                crypto.getRandomValues(userId);
                
                const publicKeyCredentialCreationOptions = {
                    challenge: challenge,
                    rp: {
                        name: "CEC-WAM-HOT-CORE",
                        id: window.location.hostname
                    },
                    user: {
                        id: userId,
                        name: "cec-wam-owner",
                        displayName: "CEC-WAM System Owner"
                    },
                    pubKeyCredParams: [
                        { alg: -7, type: "public-key" },  // ES256
                        { alg: -257, type: "public-key" } // RS256
                    ],
                    authenticatorSelection: {
                        authenticatorAttachment: "platform", // Prefer built-in authenticators (Touch ID, Face ID, Windows Hello, Android fingerprint)
                        requireResidentKey: false,
                        userVerification: "required"
                    },
                    timeout: 60000,
                    attestation: "none"
                };
                
                // Create credential
                const credential = await navigator.credentials.create({
                    publicKey: publicKeyCredentialCreationOptions
                });
                
                // Store credential ID for future authentication
                const credentialId = arrayBufferToBase64(credential.rawId);
                localStorage.setItem('biometric_credential_id', credentialId);
                localStorage.setItem('biometric_registered_at', new Date().toISOString());
                
                scanStatus.innerHTML = '<span style="color: #00FF88;">‚úì BIOMETRIC REGISTERED SUCCESSFULLY</span>';
                
                // Wait a moment then authenticate
                setTimeout(() => {
                    authenticateBiometric();
                }, 1500);
                
            } catch (error) {
                console.error('Biometric registration failed:', error);
                
                // Provide user-friendly error messages
                let errorMsg = 'Registration failed';
                
                if (error.name === 'NotAllowedError') {
                    errorMsg = 'Biometric registration was cancelled or denied. Please try again and allow access to your biometric sensor.';
                } else if (error.name === 'InvalidStateError') {
                    errorMsg = 'A biometric credential may already exist. Try authenticating instead.';
                } else if (error.name === 'NotSupportedError') {
                    errorMsg = 'Biometric registration is not supported on this device or browser.';
                } else if (error.name === 'AbortError') {
                    errorMsg = 'Registration was aborted. Please try again.';
                } else if (error.message) {
                    errorMsg = error.message;
                }
                
                setStatusMessage(scanStatus, '‚úó ' + errorMsg, '#FF4D6D');
                setupButtons.style.display = 'block';
                
                // Show manual override button on registration failure
                const manualOverrideButton = document.getElementById('manualOverrideButton');
                if (manualOverrideButton) {
                    manualOverrideButton.style.display = 'block';
                }
            }
        }
        
        // Authenticate using biometric
        async function authenticateBiometric() {
            const scanStatus = document.getElementById('scanStatus');
            const biometricButtons = document.getElementById('biometricButtons');
            
            try {
                scanStatus.innerHTML = '<span class="scanning">‚óè Verifying biometric credential...</span>';
                biometricButtons.style.display = 'none';
                
                // Check WebAuthn support
                if (!window.PublicKeyCredential) {
                    throw new Error('WebAuthn is not supported on this device/browser');
                }
                
                // Get stored credential ID
                const credentialIdB64 = localStorage.getItem('biometric_credential_id');
                if (!credentialIdB64) {
                    throw new Error('No biometric credential found. Please register first.');
                }
                
                // Generate authentication challenge
                const challenge = generateRandomChallenge();
                const credentialId = base64ToArrayBuffer(credentialIdB64);
                
                // Create authentication request options
                const publicKeyCredentialRequestOptions = {
                    challenge: challenge,
                    allowCredentials: [{
                        id: credentialId,
                        type: 'public-key',
                        transports: ['internal']
                    }],
                    timeout: 60000,
                    userVerification: "required",
                    rpId: window.location.hostname
                };
                
                // Authenticate with biometric
                const assertion = await navigator.credentials.get({
                    publicKey: publicKeyCredentialRequestOptions
                });
                
                // Authentication successful
                scanStatus.innerHTML = '<span style="color: #00FF88;">‚úì BIOMETRIC VERIFIED - ACCESS GRANTED</span>';
                
                // Store last authentication time
                localStorage.setItem('last_auth_time', new Date().toISOString());
                
                // Unlock dashboard
                setTimeout(() => {
                    unlockDashboard();
                }, 800);
                
            } catch (error) {
                console.error('Biometric authentication failed:', error);
                
                // Provide user-friendly error messages
                let errorMsg = 'Authentication failed';
                
                if (error.name === 'NotAllowedError') {
                    errorMsg = 'Biometric verification was cancelled or timed out. Please try again.';
                } else if (error.name === 'InvalidStateError') {
                    errorMsg = 'Biometric sensor is not available. Please ensure it\'s enabled.';
                } else if (error.name === 'NotSupportedError') {
                    errorMsg = 'Biometric authentication is not supported on this device.';
                } else if (error.name === 'AbortError') {
                    errorMsg = 'Authentication was aborted. Please try again.';
                } else if (error.message) {
                    errorMsg = error.message;
                }
                
                setStatusMessage(scanStatus, '‚úó ' + errorMsg, '#FF4D6D');
                biometricButtons.style.display = 'block';
                
                // Always show manual override button on authentication failure with clear visibility
                const manualOverrideButton = document.getElementById('manualOverrideButton');
                if (manualOverrideButton) {
                    manualOverrideButton.style.display = 'block';
                    manualOverrideButton.classList.add('override-pulse');
                }
                
                // Show clear hint
                document.getElementById('lockHint').textContent = 
                    'Authentication failed. Use Manual Override button below to proceed without biometrics.';
            }
        }
        
        // Manual override function to bypass biometric authentication
        function manualOverride() {
            const scanStatus = document.getElementById('scanStatus');
            scanStatus.innerHTML = '<span style="color: #FFC107;">‚ö† Manual Override Activated</span>';
            
            // Log override for security audit
            console.log('Manual override activated by user at', new Date().toISOString());
            localStorage.setItem('last_manual_override', new Date().toISOString());
            
            // Show confirmation message
            setTimeout(() => {
                scanStatus.innerHTML = '<span style="color: #00FF88;">‚úì ACCESS GRANTED VIA MANUAL OVERRIDE</span>';
            }, 500);
            
            // Unlock dashboard
            setTimeout(() => {
                unlockDashboard();
            }, 1200);
        }
        
        // Unlock the dashboard after successful authentication
        function unlockDashboard() {
            // Clear the manual override timeout to prevent race condition
            if (manualOverrideTimeout) {
                clearTimeout(manualOverrideTimeout);
                manualOverrideTimeout = null;
            }
            
            const lockScreen = document.getElementById('lockScreen');
            lockScreen.classList.add('hidden');
            
            setTimeout(() => {
                document.getElementById('mainContent').classList.add('visible');
                initDashboard();
            }, 500);
        }
        
        // Initialize biometric authentication on page load
        async function initBiometricAuth() {
            const scanStatus = document.getElementById('scanStatus');
            const biometricButtons = document.getElementById('biometricButtons');
            const setupButtons = document.getElementById('setupButtons');
            const lockHint = document.getElementById('lockHint');
            const manualOverrideButton = document.getElementById('manualOverrideButton');
            
            // Show manual override button after a delay as fallback
            manualOverrideTimeout = setTimeout(() => {
                if (manualOverrideButton && !document.getElementById('lockScreen').classList.contains('hidden')) {
                    manualOverrideButton.style.display = 'block';
                }
            }, 5000); // Show after 5 seconds
            
            // Check if WebAuthn is supported
            if (!window.PublicKeyCredential) {
                scanStatus.innerHTML = '<span style="color: #FFC107;">‚ö† Biometric authentication not available</span>';
                lockHint.textContent = 'Your browser does not support biometric authentication. Use Manual Override to proceed.';
                manualOverrideButton.style.display = 'block'; // Show immediately if not supported
                return;
            }
            
            // Check if biometric authenticators are available
            try {
                const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
                
                if (!available) {
                    scanStatus.innerHTML = '<span style="color: #FFC107;">‚ö† No biometric hardware detected</span>';
                    lockHint.textContent = 'No fingerprint sensor or Face ID detected. Use Manual Override to proceed.';
                    manualOverrideButton.style.display = 'block'; // Show immediately if no hardware
                    return;
                }
                
                // Check if user has registered biometric
                if (hasRegisteredBiometric()) {
                    scanStatus.innerHTML = '<span style="color: #00D9FF;">‚óè Biometric credential found - ready to authenticate</span>';
                    biometricButtons.style.display = 'block';
                    lockHint.textContent = 'Click AUTHENTICATE to verify your identity using fingerprint or Face ID';
                    
                    // Auto-authenticate after configured delay
                    setTimeout(() => {
                        authenticateBiometric();
                    }, AUTO_AUTH_DELAY_MS);
                } else {
                    scanStatus.innerHTML = '<span style="color: #00D9FF;">‚óè No biometric registered - setup required</span>';
                    setupButtons.style.display = 'block';
                    lockHint.textContent = 'Register your fingerprint or Face ID to secure this dashboard';
                }
            } catch (error) {
                console.error('Error checking biometric availability:', error);
                scanStatus.innerHTML = '<span style="color: #FFC107;">‚ö† Could not check biometric availability</span>';
                lockHint.textContent = 'Error checking biometric support. Use Manual Override to proceed.';
                manualOverrideButton.style.display = 'block'; // Show immediately on error
            }
        }
        
        // Initialize biometric auth when page loads
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', () => {
                initBiometricAuth();
            });
        } else {
            // DOM already loaded, initialize immediately
            initBiometricAuth();
        }
        
        // Dashboard Functions
        // Configuration for multiple data sources
        const DATA_SOURCES = {
            'main': {
                name: 'Main Ledger',
                url: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vREgUUHPCzTBWK8i1PWBrE2E4pKRTAgaReJahFqmrTetCZyCO0QHVlAleodUsTlJv_86KpzH_NPv9dv/pub?output=csv'
            }
            // Add more sheets here as needed:
            // 'sheet2': { name: 'Secondary Data', url: 'https://...' },
            // 'sheet3': { name: 'Analytics', url: 'https://...' }
        };
        
        // Configuration constants
        const FETCH_TIMEOUT_MS = 15000; // 15 second timeout for API requests
        
        let currentDataSource = 'main';
        const GOOGLE_SHEETS_CSV_URL = DATA_SOURCES[currentDataSource].url;
        const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=tridentdao&vs_currencies=usd&include_24hr_change=true';
        
        let dashboardData = null;
        let currentFilter = 'ALL';
        let priceChart = null;
        let statusChart = null;
        let trendsChart = null;
        let priceHistory = [];
        const dashboardStartTime = Date.now();
        const TOTAL_SUPPLY = 1000000; // Total supply for market cap calculation
        
        function updateTimestamp() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('lastSync').textContent = timeString;
        }
        
        async function fetchPSIPrice() {
            try {
                const response = await fetch(COINGECKO_API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                const price = data.tridentdao?.usd || 0;
                const change = data.tridentdao?.usd_24h_change || 0;
                
                const changeColor = change >= 0 ? '#00FF88' : '#FF4444';
                const changeSymbol = change >= 0 ? '+' : '';
                
                // Store price history
                priceHistory.push({
                    time: new Date().toLocaleTimeString(),
                    price: price
                });
                
                // Keep only last 20 data points
                if (priceHistory.length > 20) {
                    priceHistory.shift();
                }
                
                document.getElementById('psiPrice').innerHTML = `
                    <div class="metric">
                        <span class="metric-label">TridentDAO (PSI)</span>
                        <span class="metric-value">$${price.toFixed(6)}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">24h Change</span>
                        <span class="metric-value" style="color: ${changeColor};">${changeSymbol}${change.toFixed(2)}%</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Market Cap</span>
                        <span class="metric-value">$${(price * TOTAL_SUPPLY).toFixed(2)}</span>
                    </div>
                `;
                
                updatePriceChart();
            } catch (error) {
                console.error('Error fetching PSI price:', error);
                document.getElementById('psiPrice').innerHTML = `
                    <p style="color: #FF4444;">‚ùå Price data unavailable</p>
                    <p style="font-size: 0.9rem; opacity: 0.7;">${error.message}</p>
                `;
            }
        }
        
        function updatePriceChart() {
            const ctx = document.getElementById('priceChart');
            if (!ctx) return;
            
            if (priceChart) {
                priceChart.destroy();
            }
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: priceHistory.map(p => p.time),
                    datasets: [{
                        label: 'Price (USD)',
                        data: priceHistory.map(p => p.price),
                        borderColor: '#00D9FF',
                        backgroundColor: 'rgba(0, 217, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#00D9FF' },
                            grid: { color: 'rgba(0, 217, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#00D9FF', maxTicksLimit: 5 },
                            grid: { display: false }
                        }
                    }
                }
            });
        }
        
        async function fetchGoogleSheetsData() {
            const loadStart = Date.now();
            try {
                // Add timeout for fetch request
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
                
                const response = await fetch(GOOGLE_SHEETS_CSV_URL, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const csvText = await response.text();
                
                // Validate CSV data before processing
                if (!csvText || csvText.trim().length === 0) {
                    throw new Error('Received empty data from Google Sheets');
                }
                
                // Simple CSV parsing (handles basic cases)
                // Note: For production, consider using a CSV parsing library for complex data
                const lines = csvText.trim().split('\n');
                
                if (lines.length < 2) {
                    throw new Error('Invalid CSV format: insufficient data rows');
                }
                
                const headers = lines[0].split(',').map(h => h.trim());
                
                if (headers.length === 0) {
                    throw new Error('Invalid CSV format: no headers found');
                }
                
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim());
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });
                    data.push(row);
                }
                
                // Only update dashboardData if we have valid data
                if (data.length > 0) {
                    dashboardData = data;
                    const loadTime = ((Date.now() - loadStart) / 1000).toFixed(2);
                    document.getElementById('loadTime').textContent = `${loadTime}s`;
                    document.getElementById('dataPoints').textContent = data.length;
                    
                    displayData(data, headers);
                    updateDataSummary(data);
                    updateStatusDistribution(data);
                } else {
                    throw new Error('No valid data rows found in CSV');
                }
                updateTrendsChart(data);
                
            } catch (error) {
                console.error('Error fetching Google Sheets data:', error);
                document.getElementById('dataTable').innerHTML = `
                    <p style="color: #FF4444;">‚ùå Failed to load spreadsheet data</p>
                    <p style="font-size: 0.9rem; opacity: 0.7;">${error.message}</p>
                    <p style="font-size: 0.9rem; opacity: 0.7;">Please check your internet connection and verify the Google Sheets URL is accessible.</p>
                `;
            }
        }
        
        // Data masking function for sensitive fields
        function maskSensitiveData(value, fieldName) {
            // List of sensitive field patterns
            const sensitivePatterns = [
                /key/i, /password/i, /secret/i, /token/i, /api/i,
                /wallet/i, /private/i, /seed/i, /pin/i, /ssn/i
            ];
            
            // Check if field name matches sensitive patterns
            const isSensitive = sensitivePatterns.some(pattern => pattern.test(fieldName));
            
            if (isSensitive && value && value.length > 0) {
                // Mask based on length for better security
                if (value.length <= 2) {
                    return '**';
                } else if (value.length <= 4) {
                    return '****';
                } else if (value.length <= 8) {
                    return value.slice(0, 1) + '******' + value.slice(-1);
                } else {
                    // Show only first 2 and last 2 characters for longer values
                    return value.slice(0, 2) + '******' + value.slice(-2);
                }
            }
            
            return value;
        }
        
        function displayData(data, headers) {
            let html = '<table class="data-table"><thead><tr>';
            
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            data.forEach(row => {
                const statusClass = getStatusClass(row.Status || row.status || '');
                html += `<tr class="${statusClass}">`;
                headers.forEach(header => {
                    const rawValue = row[header] || '';
                    // Apply data masking for sensitive fields in UI
                    const displayValue = maskSensitiveData(rawValue, header);
                    html += `<td>${displayValue}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            document.getElementById('dataTable').innerHTML = html;
        }
        
        function getStatusClass(status) {
            const statusUpper = status.toUpperCase();
            if (statusUpper.includes('PERFECT')) return 'status-perfect';
            if (statusUpper.includes('TODO')) return 'status-todo';
            if (statusUpper.includes('ACTIVE')) return 'status-active';
            if (statusUpper.includes('STABLE')) return 'status-stable';
            return '';
        }
        
        function updateDataSummary(data) {
            // Calculate numeric values if Value column exists
            let totalValue = 0;
            let avgValue = 0;
            let numericCount = 0;
            
            data.forEach(row => {
                const value = parseFloat(row.Value || row.value || 0);
                if (!isNaN(value) && value !== 0) {
                    totalValue += value;
                    numericCount++;
                }
            });
            
            avgValue = numericCount > 0 ? totalValue / numericCount : 0;
            
            document.getElementById('dataSummary').innerHTML = `
                <div class="metric">
                    <span class="metric-label">Total Records</span>
                    <span class="metric-value">${data.length}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Updated</span>
                    <span class="metric-value">${new Date().toLocaleString()}</span>
                </div>
            `;
            
            document.getElementById('avgValue').textContent = avgValue > 0 ? `$${avgValue.toFixed(2)}` : '--';
            document.getElementById('totalValue').textContent = totalValue > 0 ? `$${totalValue.toFixed(2)}` : '--';
        }
        
        function updateStatusDistribution(data) {
            const statusCount = {};
            data.forEach(row => {
                const status = row.Status || row.status || 'Unknown';
                statusCount[status] = (statusCount[status] || 0) + 1;
            });
            
            let html = '';
            Object.entries(statusCount).forEach(([status, count]) => {
                html += `
                    <div class="metric">
                        <span class="metric-label">${status}</span>
                        <span class="metric-value">${count}</span>
                    </div>
                `;
            });
            
            document.getElementById('statusDist').innerHTML = html || '<p>No status data</p>';
            
            // Update status chart
            updateStatusChart(statusCount);
        }
        
        function updateStatusChart(statusCount) {
            const ctx = document.getElementById('statusChart');
            if (!ctx) return;
            
            if (statusChart) {
                statusChart.destroy();
            }
            
            const labels = Object.keys(statusCount);
            const values = Object.values(statusCount);
            const colors = labels.map(status => {
                const s = status.toUpperCase();
                if (s.includes('PERFECT')) return '#00FF88';
                if (s.includes('TODO')) return '#FFC107';
                if (s.includes('ACTIVE')) return '#2196F3';
                if (s.includes('STABLE')) return '#9E9E9E';
                return '#00D9FF';
            });
            
            statusChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: colors,
                        borderColor: '#0E0E1A',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#00D9FF',
                                padding: 10
                            }
                        }
                    }
                }
            });
        }
        
        function updateTrendsChart(data) {
            const ctx = document.getElementById('trendsChart');
            if (!ctx) return;
            
            if (trendsChart) {
                trendsChart.destroy();
            }
            
            // Extract numeric values for trend analysis
            const values = data.map((row, index) => ({
                index: index + 1,
                value: parseFloat(row.Value || row.value || 0)
            })).filter(item => !isNaN(item.value) && item.value !== 0);
            
            trendsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: values.map(v => `#${v.index}`),
                    datasets: [{
                        label: 'Data Values',
                        data: values.map(v => v.value),
                        backgroundColor: 'rgba(0, 217, 255, 0.5)',
                        borderColor: '#00D9FF',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#00D9FF'
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#00D9FF' },
                            grid: { color: 'rgba(0, 217, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#00D9FF', maxTicksLimit: 10 },
                            grid: { display: false }
                        }
                    }
                }
            });
        }
        
        function refreshData() {
            // Parallelize API calls for better performance
            // Both requests execute simultaneously instead of sequentially
            Promise.all([
                fetchPSIPrice(),
                fetchGoogleSheetsData()
            ]).then(() => {
                updateTimestamp();
            }).catch(error => {
                console.error('Error refreshing data:', error);
                updateTimestamp();
            });
        }
        
        function filterData(status, event) {
            currentFilter = status;
            
            // Update button states
            document.querySelectorAll('.filter-button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            if (!dashboardData) return;
            
            let filteredData = dashboardData;
            if (status !== 'ALL') {
                filteredData = dashboardData.filter(row => {
                    const rowStatus = (row.Status || row.status || '').toUpperCase();
                    return rowStatus.includes(status);
                });
            }
            
            const headers = Object.keys(dashboardData[0] || {});
            displayData(filteredData, headers);
        }
        
        function exportData() {
            if (!dashboardData || dashboardData.length === 0) {
                alert('No data available to export');
                return;
            }
            
            // Convert data to CSV with proper escaping
            const headers = Object.keys(dashboardData[0]);
            let csv = headers.join(',') + '\n';
            
            dashboardData.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    // Escape commas, quotes, and newlines
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                });
                csv += values.join(',') + '\n';
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cec-wam-data-${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        function initDashboard() {
            updateTimestamp();
            
            // Parallelize initial data fetch for faster load time
            Promise.all([
                fetchPSIPrice(),
                fetchGoogleSheetsData()
            ]).then(() => {
                console.log('‚úì Dashboard data loaded successfully');
            }).catch(error => {
                console.error('‚úó Error loading dashboard data:', error);
            });
            
            initStarMap();
            
            // Auto-refresh every 30 seconds for real-time data updates
            // Only refresh if page is visible to save bandwidth
            setInterval(() => {
                if (!document.hidden) {
                    refreshData();
                }
            }, 30000);  // 30000ms = 30 seconds
            
            // Also refresh when page becomes visible after being hidden
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    console.log('Page became visible - refreshing data');
                    refreshData();
                }
            });
        }
        
        // =================================================================
        // 3D Star Map Implementation with Caching
        // Generates 10,000 star vertices once and reuses them
        // =================================================================
        
        // Cache star vertices to avoid regenerating on every call
        let cachedStarsVertices = null;
        
        function generateStarVertices() {
            if (cachedStarsVertices) {
                return cachedStarsVertices;
            }
            
            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            cachedStarsVertices = starsVertices;
            return starsVertices;
        }
        
        function initStarMap() {
            const container = document.getElementById('starmap-container');
            const canvas = document.getElementById('starmap');
            
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setClearColor(0x000000);
            
            // Add stars using cached vertices
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.7 });
            
            const starsVertices = generateStarVertices();
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
            
            // Alpha Centauri (Yellow Star)
            const alphaCentauriGeometry = new THREE.SphereGeometry(2, 32, 32);
            const alphaCentauriMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const alphaCentauri = new THREE.Mesh(alphaCentauriGeometry, alphaCentauriMaterial);
            alphaCentauri.position.set(0, 0, 0);
            scene.add(alphaCentauri);
            
            // Orbit for Alpha Centauri
            const orbitGeometry1 = new THREE.RingGeometry(15, 15.2, 64);
            const orbitMaterial1 = new THREE.MeshBasicMaterial({ color: 0xFFFF00, side: THREE.DoubleSide });
            const orbit1 = new THREE.Mesh(orbitGeometry1, orbitMaterial1);
            orbit1.rotation.x = Math.PI / 2;
            scene.add(orbit1);
            
            // TRAPPIST-1e (Blue-Green Exoplanet)
            const trappistGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const trappistMaterial = new THREE.MeshBasicMaterial({ color: 0x00FFAA });
            const trappist = new THREE.Mesh(trappistGeometry, trappistMaterial);
            scene.add(trappist);
            
            // Orbit for TRAPPIST-1e
            const orbitGeometry2 = new THREE.RingGeometry(25, 25.2, 64);
            const orbitMaterial2 = new THREE.MeshBasicMaterial({ color: 0x00FFAA, side: THREE.DoubleSide });
            const orbit2 = new THREE.Mesh(orbitGeometry2, orbitMaterial2);
            orbit2.rotation.x = Math.PI / 2;
            scene.add(orbit2);
            
            // Ross 128 b (Red Exoplanet)
            const rossGeometry = new THREE.SphereGeometry(1.2, 32, 32);
            const rossMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4444 });
            const ross = new THREE.Mesh(rossGeometry, rossMaterial);
            scene.add(ross);
            
            // Orbit for Ross 128 b
            const orbitGeometry3 = new THREE.RingGeometry(35, 35.2, 64);
            const orbitMaterial3 = new THREE.MeshBasicMaterial({ color: 0xFF4444, side: THREE.DoubleSide });
            const orbit3 = new THREE.Mesh(orbitGeometry3, orbitMaterial3);
            orbit3.rotation.x = Math.PI / 2;
            scene.add(orbit3);
            
            camera.position.z = 50;
            camera.position.y = 20;
            
            let angle1 = 0;
            let angle2 = 0;
            let angle3 = 0;
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Rotate planets in orbits
                angle1 += 0.01;
                angle2 += 0.007;
                angle3 += 0.005;
                
                trappist.position.x = Math.cos(angle1) * 25;
                trappist.position.z = Math.sin(angle1) * 25;
                
                ross.position.x = Math.cos(angle2) * 35;
                ross.position.z = Math.sin(angle2) * 35;
                
                // Rotate camera slightly
                camera.position.x = Math.cos(angle3 * 0.1) * 50;
                camera.position.z = Math.sin(angle3 * 0.1) * 50;
                camera.lookAt(0, 0, 0);
                
                // Rotate star field
                starField.rotation.y += 0.0002;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Debounced window resize handler to prevent excessive updates
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    camera.aspect = container.offsetWidth / container.offsetHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.offsetWidth, container.offsetHeight);
                }, 250);  // 250ms debounce delay
            });
        }
    </script>
</body>
</html>
